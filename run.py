#TODO Gestion des permissions d'acc√®s
#from flask_service_tools import APIResponse, RequestValidator, DBManager, AuthManager, Config, AIGatewayClient
from app.db_handler import DbHandler
from app.github import GitHubService
from app.changelog_parser import ChangelogParser
from app.changelog_writer import ChangelogWriter

def main():
    while True:
        current_dolibarr_version = input("Veuillez entrer le num√©ro de version de Dolibarr (ex: 19) : ").strip()
        if current_dolibarr_version.isdigit():  # V√©rifier si l'utilisateur a entr√© quelque chose
            break
        else:
            print("Entr√©e invalide. Veuillez entrer uniquement un num√©ro de version entier (ex: 19, 20).")

    # Demander le token GitHub interactivement
    while True:
        current_github_token = input("Veuillez entrer votre token d'acc√®s GitHub : ").strip()
        if not current_github_token:
            print("Le token GitHub ne peut pas √™tre vide. Veuillez r√©essayer.")
        else:
            break
            
#TODO V√©rifier que le token a les bon droits/authentique via un appel √† Access Control
    # --- Initialisation des Services et Gestionnaires ---
    print("üîß Initialisation des services...")
    github_service = GitHubService(current_github_token)  # Service pour l'API GitHub
    parser = ChangelogParser()  # Parser pour le texte du ChangeLog
    writer = ChangelogWriter()  # Utilitaire d'√©criture de fichiers (usage optionnel ici)
    db = DbHandler(current_dolibarr_version)  # Gestionnaire BD (SQLite) pour la version cible

    # --- √âtape 1: T√©l√©chargement du Fichier ChangeLog ---
    print(f"\nüì• √âtape 1: T√©l√©chargement du ChangeLog Dolibarr...")
    changelog_content = github_service.fetch_raw_file_content(
        owner='Dolibarr',
        repo='dolibarr',
        branch='develop',
        filepath='ChangeLog'
    )

    if changelog_content:
        print("  ‚úÖ ChangeLog t√©l√©charg√©.")

        # --- √âtape 2: Extraction de la Section pour la Version Cible ---
        print(f"\nüîé √âtape 2: Extraction de la section pour la v{current_dolibarr_version}...")
        # `section_lines` doit √™tre une liste de cha√Ænes (lignes de la section).
        section_lines = parser.extract_version_section(changelog_content, current_dolibarr_version)

        if section_lines:  # Si la section est trouv√©e et non vide
            print(f"  ‚úÖ Section v{current_dolibarr_version} extraite ({len(section_lines)} lignes).")

            writer.save_lines_to_file(section_lines, current_dolibarr_version)
            print(f"  üìÑ Section sauvegard√©e localement.")

            # --- √âtape 3: Traitement et Int√©gration Base de Donn√©es ---
            print(f"\nüóÉÔ∏è √âtape 3: Traitement de la base de donn√©es pour la v{current_dolibarr_version}...")
            try:
                # Phase 1 BD: Pr√©paration de la table et insertion initiale des lignes brutes.
                print("  [Phase 1 BD] Pr√©paration table et insertion initiale...")
                db.create_changelog_table()  # Assure que la table pour la version existe.

                # La m√©thode `determine_line_type_and_process_db` doit analyser `section_lines`,
                # d√©terminer le type de chaque ligne, et l'ins√©rer en base via `db.insert_changelog_line`.
                # Les lignes sont ins√©r√©es avec `is_done=False`, `not_supported=False`.
                if hasattr(parser, 'determine_line_type_and_process_db'):
                    parser.determine_line_type_and_process_db(db, section_lines)
                else:
                    # Avertissement si la m√©thode d'insertion/parsing initiale est manquante.
                    print(
                        "  ‚ö†Ô∏è 'determine_line_type_and_process_db' non trouv√©e sur le parser. L'insertion initiale peut √™tre incompl√®te.")
                    print("     Veuillez impl√©menter cette logique ou une alternative pour peupler la base de donn√©es.")

                # Phase 2 BD: Enrichissement des lignes stock√©es en base (infos PRs, diffs).
                print("\n  [Phase 2 BD] Enrichissement des donn√©es via l'API GitHub...")
                # La m√©thode `process_changelog_lines_refactored` (ou nom √©quivalent) :
                # 1. Lit les lignes non trait√©es de la BD (`db.get_lines_to_process()`).
                # 2. Contacte GitHub (via `self.github_service`) pour infos PR et diffs.
                # 3. Met √† jour les lignes en BD avec les informations enrichies.
                concatenated_prompts = parser.process_changelog_lines_refactored(db_handler=db, github_service=github_service)
                writer.save_text_block(concatenated_prompts, 'prompts.txt')
                print("\n‚úÖ Traitement de la base de donn√©es termin√©.")

            except Exception as e:  # Capture les erreurs durant les op√©rations sur la base de donn√©es.
                print(f"‚ùå Erreur majeure durant le traitement de la base de donn√©es : {e}")
                import traceback

                traceback.print_exc()  # Affiche la trace compl√®te pour faciliter le d√©bogage.
        else:
            print(
                f"‚ÑπÔ∏è Section pour la v{current_dolibarr_version} non trouv√©e dans le ChangeLog ou vide. Arr√™t du traitement.")
    else:
        print("‚ÑπÔ∏è T√©l√©chargement du fichier ChangeLog √©chou√©. Arr√™t du traitement.")

if __name__ == "__main__":
    main()